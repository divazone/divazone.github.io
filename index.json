[{"categories":["dev"],"content":" 寫程式是一種技能，可以讓我們不斷提升和學習新知識。 寫程式是一門永遠學不完的手藝。我們無法掌握所有與寫程式相關的主題，因為這涉及的內容太多。如果想要自己不斷進步，必須保持開放的心態，不斷獲取新知識，並接受無法掌握全部知識的事實。讓自己每天都有進步就夠了。 可以通過以下三種方式實現這一目標： ","date":"2024-09-04","objectID":"/2024/09/20240904-how-to-improve-programming-skills/:0:0","tags":["dev"],"title":"如何提升寫程式的能力","uri":"/2024/09/20240904-how-to-improve-programming-skills/"},{"categories":["dev"],"content":"日常寫程式 寫程式是一項與其他技術一樣的技能。想要把它做好，需要大量的練習和努力。沒有人會在一覺醒來後就突然變得擅長寫程式。所有優秀的工程師都日以繼夜地工作，以完善他們的寫程式技能。不論你正在做什麼專案，使用什麼程式語言，都要養成每天撰寫程式碼的習慣——重要的是每天都要寫程式。 不要只是寫程式，嘗試閱讀其他程式設計師的程式碼，與他們討論程式碼，並尋找高手來檢視（review）你的程式碼。寫程式是一門技藝精湛的手藝，不能僅僅通過學習語法規則就能精通，只有不斷的練習與反思，才能取得好成績。 ","date":"2024-09-04","objectID":"/2024/09/20240904-how-to-improve-programming-skills/:1:0","tags":["dev"],"title":"如何提升寫程式的能力","uri":"/2024/09/20240904-how-to-improve-programming-skills/"},{"categories":["dev"],"content":"學習多種程式語言 大學課程中引入多種程式語言是有原因的，寫程式的知識通過語言進行傳播。例如，熟悉 Java 語言的物件導向程式設計讓你更容易理解 Go 語言中的概念，因為一些相同的程式設計概念適用於這兩種語言。 當我們從多種語言中學習到不同的概念時，寫程式才開始變得真正有趣。我從 Go 中學到了結構體，從 Python 中學到了函式程式設計，從 Java 中學到了物件導向程式設計。將多種語言的特性結合起來，無疑有助於我鞏固整體思維格局，並使我在寫程式方面更上層樓。不要局限在一個小角落，經常嘗試和探索未知的事物，即使覺得自己什麼都不知道也沒關係，畢竟吸收新資訊是我們學習的唯一方式。 人最害怕的不是自己什麼都不會，而是自己不知道自己不會。 ","date":"2024-09-04","objectID":"/2024/09/20240904-how-to-improve-programming-skills/:2:0","tags":["dev"],"title":"如何提升寫程式的能力","uri":"/2024/09/20240904-how-to-improve-programming-skills/"},{"categories":["dev"],"content":"教導和幫助其他程式設計師 聽過門徒效應嗎？這是一種通過教別人來學習的有趣方式。門徒效應是一種現象，教授或準備將知識傳授給他人可以幫助自己學習這些知識。 教授一門課程意味著你必須從不同角度來掌握它，因為你不知道學生已經掌握了多少。因此，你需要假設學生對該主題了解不多，這也意味著你必須從最基礎的知識開始教學。而教授基礎知識的唯一方法就是自己要徹底理解這些基礎知識。 通過教學來學習可以借鑒小黃鴨除錯法。有證據顯示，教一個無生命的物體可以提高對所教知識的理解和掌握。 我們可以從小事開始，試著每天幫助一個人：在 GitHub 上挑選一個 issue 並解決它。為了盡可能多地學習和幫助他人，也可以在 SegmentFault 或 StackOverflow 上回答問題。 ","date":"2024-09-04","objectID":"/2024/09/20240904-how-to-improve-programming-skills/:3:0","tags":["dev"],"title":"如何提升寫程式的能力","uri":"/2024/09/20240904-how-to-improve-programming-skills/"},{"categories":["dev"],"content":"最後 儘管寫程式難以掌握，但它非常有趣。問問自己：如果你真的想掌握寫程式，是否願意付出額外的努力？我想你已經知道答案了。 ","date":"2024-09-04","objectID":"/2024/09/20240904-how-to-improve-programming-skills/:4:0","tags":["dev"],"title":"如何提升寫程式的能力","uri":"/2024/09/20240904-how-to-improve-programming-skills/"},{"categories":["linux"],"content":"常常聽到一些客戶反映他們的系統速度很慢，但通常無法明確指出慢在哪里。這裡提供一個簡單的方法，當遇到當下系統速度變慢的情況時，可以通過一些數字來判斷瓶頸點（Bound）。這篇文章僅從操作系統層面進行說明，不涉及應用程序層級的效能問題。 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:0:0","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"系統壓力觀測目標 sar - Clliect, report, or save system activity information 本文將使用 sar 系統活動報告器來貫穿所有操作，主要觀測點有以下五個： CPU Disk I/O Network Memory Swap 選用 sar 的理由如下： 數據收集過程對系統本身造成的壓力最小 大多數 Linux 發行版均可使用 指令簡單易用 是目前 Linux 上較為全面的系統效能分析工具之一 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:1:0","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"環境介紹 Archlinux ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:2:0","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"安裝 sudo pacman -S sysstat ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:3:0","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"常常遇到的問題 [聲明] 如果以下的欄位解釋覺得翻譯得不好，可以參考 man sar 的英文版解釋 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:4:0","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"懷疑系統是不是真的忙? sar -q 1 60 指令解釋: 每隔 1 秒收集一次，一共收集 60 次平均常見的負載 (1m / 5m / 15m)數字 欄位解釋: runq-sz: 運行中的 Quene 長度 (等待運行的 Tasks 數) plist-sz: Tasks 列表中的 tasks 數量 ldavg-1: 最後 1 分鐘的系統平均負載量 ldavg-5: 最後 5 分鐘的系統平均負載量 ldavg-15: 最後 15 分鐘的系統平均負載量 數字解讀: 現在都是支援多核 CPU，故 n 個 CPU Core，可接受的系統負荷最大 n.0 確認系統核心數的指令是 grep -c 'model name' /proc/cpuinfo 通常來講是看 ldavg-15，如果長期接近或大於 n 的話，就是系統負擔過大 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:4:1","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"懷疑是 CPU Bound? sar -u 2 10 //看 CPU Overview 使用率 (與 mpstat 相同) sar -P ALL 2 10 //看個別 CPU 使用率 (與 mpstat -P ALL 相同) 指令解釋: 每隔 2 秒收集一次，一共收集 10 次所有 CPU 的效能數據 欄位解釋 %user: 於 User (Application) 等級之下，消耗的 CPU 時間比例 %nice: 透過 nice 改變優先級，於 User (Application) 等級之下，消耗的 CPU 時間的比例 %system: 於 System (Kernel) 等級之下，消耗的 CPU 時間比例 %iowait: CPU 等待 Disk I/O 導致空閑狀態 (Idle) 消耗的時間比例 %steal: 利用虛擬化技術，等待其他 vCPU 計算佔用的時間比例 %idle: CPU 空閑時間比例 數字解讀 %iowait 過高，有可能是 Disk I/O 瓶頸，要改善 Disk %idle 過高，有可能是 CPU 等待分配 Memory，要看一下記憶體是不是不夠 %idle 持續低於 10，則代表 CPU 處理效率低，需要解決 CPU 瓶頸 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:4:2","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"懷疑是 Network Bound? sar -n DEV 2 10 指令解讀: 每隔 2 秒收集一次，一共收集 10 次所有網卡的效能數據 欄位解釋: rxpck/s: 每秒接收到的封包量 txpck/s: 每秒傳送出的封包量 rxkB/s: 每秒接收到的 bytes 數量 txkB/s: 每秒傳送出的 bytes 數量 rxcmp/s: 每秒接收到的壓縮後封包 txcmp/s: 每秒傳送出的壓縮後封包 rxmcst/s: 每秒接收到的群播封包 %ifutil: 網路介面使用率 數字解讀: rxpck/s 和 txpck/s 是衡量一張網卡效能的指標，數字越大壓力越大 rxkB/s 和 txkB/s 是代表吞吐量效能，數字越大壓力越大 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:4:3","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"懷疑是 Memory? sar -r 2 10 指令解釋: 每隔 2 秒收集一次，一共收集 10 次記憶體的效能數據 欄位解釋 kbmemfree: 閒置的 Free Memory 大小 kbavail: 無需透過 Swapping 即可使用的 Memory 大小 kbmemused: 使用中的 Memory %memused: 物理記憶體使用率 kbbuffers: Kernel 拿去作為 Buffer 的大小 kbcached: Kernel 拿取當作 Cached 的大小 kbcommit: Kernel 當前工作負載所需要的量，這是預估需要多少 RAM/Swap，以保證不會有記憶體不足的估計值 %commit: Kernel 當前工作負載所需記憶體佔記憶體總量 (RAM + Swap) 的百分比 kbactive: 活躍中的記憶體，除非必要，通常不會回收 (Reclaimed) kbinact: 不活躍中的記憶體，最近被使用的次數較少，有可能會被回收 kbdirty: 等待寫回至磁碟的記憶體內容 數字解讀 透過 %memused kbbuffers kbcached 可以了解到記憶體實際使用量 %commit 這是 kbcommit 與記憶體總量 (包含swap) 的百分比數字，越小代表記憶體越足夠 %commit 有可能會大於 100%，有可能 Kernel 使用過量記憶體 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:4:4","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"懷疑是 Swap Page Bound? sar -W 2 10 指令解讀: 每隔 2 秒收集一次，一共收集 10 次 Swap page out/in 的效能數據 欄位解釋 pswpin/s: 每秒系統 Swap page IN 的數量 pswpout/s: 每秒系統 Swap page Out 的數量 數字解讀 這個只要有數字跳出來，伺服器處理吞吐量會大幅下降，這時候要先確定是不是記憶體夠不夠 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:4:5","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"懷疑是 Disk I/O Bound？ sar -d 2 10 指令解讀: 每隔 2 秒收集一次，一共收集 10 次 Disk I/O 的效能數據 欄位解釋 tps: 設備每秒數據傳輸量 rkB/s: 每秒從設備讀取的資料量 wkB/s: 每秒寫入到設備的資料量 dkB/s: 每秒被設備丟棄的資料量 areq-sz: 發出到設備 I/O 請求的平均資料大小 aqu-sz: 發出到設備的 I/O 請求的平均 Queue 長度 await: 發出到服務的設備請求 I/O 的平均反應時間 %util: 向設備發出 I/O 請求的經過時間百分比 數字解讀 %util 數值越大越忙 如果剛好有 raid 之類的話，%util 有可能會大於 100% iostat 比較詳細，針對 Disk I/O 更建議使用 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:4:6","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"結語 當然，sar 並不是長期監控的最佳方案，更推薦使用 Performance Co-Pilot (PCP) PCP 快速入門 來進行系統的長期監控與維護。 通過此篇文章，希望大家在遇到系統變慢的情況時，可以先利用 sar 進行快速的初步了解，建立一個基本的認識，然後再花時間規劃更長期的系統監控方式。 ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:5:0","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["linux"],"content":"References sar 找出系统瓶颈的利器 理解Linux系统负荷 Performance Co-Pilot Linux ate My RAM Linux 的記憶體快取（Cache Memory）功能：Linux 系統把記憶體用光了？ ","date":"2024-08-02","objectID":"/2024/08/20240802-identifying-linux-performance-bottlenecks/:6:0","tags":["linux","performance"],"title":"尋找當下 Linux OS 效能瓶頸","uri":"/2024/08/20240802-identifying-linux-performance-bottlenecks/"},{"categories":["ansible"],"content":"前言 先說本文僅代表個人撰寫 Ansible Playbook及 Ansible AWX 之經驗累積。 Ansible 本身具有幾個很顯著的特點: 好寫, 易讀, Agentless，然而，說到好寫，也因為可以寫出多種風格，因此特別撰寫此文，記錄我在編寫 Ansible Playbook 時需要注意的一些事項。當然，其中一些內容會參考 Ansible 官方列出的 Ansible tips and tricks ，但大多數仍以我的個人經驗為出發點。 ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:0","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 1: 建議遵循 Ansible Direcory Layout 的最佳實踐 經常編寫 Ansible 的人都知道，通過修改 ansible.cfg 文件，可以讓許多 playbook 的變數呼叫和路徑變得非常靈活。然而，雖然可以進行修改，但強烈不建議這樣做。原因是你的同事或接手的工程師可能不了解你的個人習慣，因此建議遵循最佳實踐和推薦的文件夾命名方式。 production_inventory # production servers 主機目錄 staging_inventory # staging environment 主機目錄 group_vars/ group1 # 以 Group 為單位，賦予對應之變數 group2 host_vars/ hostname1 # 以 host 為單位，賦予對應之變數 hostname2 library/ # 任何自己寫或自己維護 (也就是非 Built-in) 的 module 都建議放這邊 module_utils/ # 個人很少在用 # 可參考 `/usr/lib/python2.7/site-packages/ansible/module_utils` 的內容 filter_plugins/ # 任何自己寫或自己維護 (也就是非 Built-in) 的filter 都建議放這邊 Do_something_for_someone_1.yml # 為了某個服務做某事，後面會有詳細建議 Do_something_for_someone_2.yml Do_something_for_someone_3.yml roles/ common/ # 其中一個 role 的名字 `common` tasks/ # common 的 tasks 資料夾 main.yml # common 相關的 tasks action 請先寫在這 handlers/ # common 裡的事件處理 main.yml # common 相關的 event handler 請先寫在這 templates/ # common 相關的 jinja2 模板 ntp.conf.j2 # common 相關的 file template 請先寫在這 files/ # common 相關的檔案庫 bar.txt # common 相關的檔案 foo.sh # common 相關的 script 放這邊 vars/ # main.yml # 跟這個 common 有相關的區域變數宣告請放這邊 defaults/ # common 相關的預設變數 main.yml # 可以寫變數預設值在這邊，但我個人比較推薦寫到 tasks 裡面的 playbook 裡，後面會有詳細建議和寫法 meta/ # common 相關的其他角色依賴 main.yml # 宣告角色依賴 library/ # 針對 common role 的函式庫 module_utils/ # 個人很少在用 lookup_plugins/ # 個人很少在用 webtier/ # 呈上的結構 ... ... ... ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:1","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 2: Playbook 命名法建議 在命名 Playbook 時，遵循 Do something for someone 的格式。我知道很多人會直接用 someone 作為 Playbook 的命名，但基於後續會提到的 Ansible AWX 帶來的 Workflow 概念——多個 Playbook 序列化執行，以及期望維護者能一眼看出這份 Playbook 主要是在針對 什麼目標做什麼事情，因此建議採用此命名規範。 #不建議 webserver.yml database.yml #建議 deploy-webserver.yml deploy-database.yml ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:2","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 3: 一個專案對應一個業務目標 Ansible 最頂端的資料夾稱為 專案 (Project)，其次是 Playbook 及 roles 等文件結構。 假設今天要部署一個 HTTP 伺服器，需要包含 lb、www、db，我會將 Playbook 分為以下幾個： Deploy_http_server install_lb.yml install_\u003cwww.yml\u003e install_db.yml check_www_service.yml 在這個案例中，專案名稱為 Deploy_http_server，裡面包含上述所列的 Playbook，以一個專案一個業務目標為核心進行 Playbook 的撰寫。 ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:3","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 4: 變數無給值時，預設使用 default 值 常寫 Shell Script 的人應該熟悉以下寫法： FOO=${VARIABLE:-default} # 如果 VARIABLE 無給值，及使用 default 值 在 Ansible 中也支援這種寫法： --- - hosts: \"{{ variable_host | default('all') }}\" tasks: - name: ... ... 這個使用情境我個人應用在部署新 VM 或更新系統時，針對特定主機時會用到。過去要針對新部署的機器進行一些修正時，都需要修改 hosts 裡面的值，現在用這個寫法可以直接這樣操作： ansible-playbook -i inventory deploy_new_vm_env --extra-vars='variable_host=192.168.50.1' 這樣就可以針對 192.168.50.1 這台機器進行部署或上 patch，如果我沒有指定任何 extra-vars 的話，則會直接對 inventory 中的所有機器（all）進行處理。 這個寫法也可以結合 Ansible AWX 裡 Survey 功能進行 Self-service 應用。 ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:4","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 5: Ansible Workflow 實作提示 這個概念源自於 Ansible AWX，它將多個 Playbook 序列化執行。這種做法適用於由多個業務目標所組成的更大業務目標。你可以將其類比為 Agile 專案術語中的 Epic / Story / Task 對應到 Ansible 的 Workflow / Playbook / Roles。 Workflow 具體寫法如下： cat deploy_openshift_cluster.yml --- - import_playbook: prerequisite_env.yml - import_playbook: deploy_core_componets.yml - import_playbook: check_componets.yml 如果你需要的話，也可以將 workflow 嵌套在 workflow 中，但除非你對抽象化程度非常有把握，否則建議最多只做一層 workflow，以應付大多數需求。 此外，這個功能主要是為了 Ansible AWX 設計的，不僅具備可視化 Workflow 的能力，還增加了更多錯誤處理功能。例如，當 Playbook 執行時出現問題，可以跳轉到錯誤處理步驟進行應對，比如發送通知等。 ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:5","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 6: 使用版本控制系統（Version Control System）管理 在這裡的版本控制系統可以是任何一家方案，例如 git、svn、mercurial 等等。沒有最好的方案，只有最適合自己的方案。我個人強烈推薦使用 git。無論你是採用集中式還是分散式的管理方式，都可以使用 git 來實現，非常好用。 遵循 Infrastructure as Code 的思想，應該對所有源代碼的變動進行記錄。使用版本控制有以下幾個好處： 允許使用者將檔案恢復到某個時間點的狀態 追蹤不同時間點的修改 確認在某個時間點進行了哪些變更，並查找導致問題的責任人 容易進行備份和管理 在 Ansible AWX 中，其專案內容的更新也是需要基於版本控制進行設定檔的變動，這樣便於進行 Playbook 的內容管理。 ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:6","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 7: 單一 host 可同時屬於多個 group host 是唯一值，而 group 可以將多個 host 定義在一起，並且可以多重定義 host。也就是說，你可以把 group 當作 tag 來使用，根據不同的角色、位置、任務來進行定義，這在使用 --limit 參數時會非常好用。 具體的 inventory 寫法如下： [infra:children] db www lb [db] tw-db.divazone.local [www] tw-www.divazone.local [lb] tw-lb.divazone.local [tw] tw-db.divazone.local tw-lb.divazone.local tw-www.divazone.local ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:7","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 8: 避免使用 ansible_connection=local，建議改用 ansible_connection=ssh 其實這裡不是說不能用 local，而是設計時請優先考慮使用 SSH 連線，有其他特殊需求再考慮使用 local，因為這主要牽涉到 Ansible 的連線行為。你可以使用 -vvv 選項來觀察連線過程。先前遇到過問題是使用 local 執行時，會有權限和環境變數的問題，經研究 issue 後，發現改成 SSH 連線後就沒有這些問題。此外，Ansible 預設的連線方式是 ansible_connection=ssh，所以在 inventory 中不用特別明寫。 具體寫法如下： # 不建議 localhost ansible_connection=local # 建議 localhost ansible_connection=ssh ansible_host=localhost ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:8","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 9: 多利用 ping 模組進行連線測試 在執行任何 Playbook 之前，我會先針對我要執行的機器跑 ping，以確保機器連接狀況正常。有時候可以通過這個動作提前發現網路和執行問題。多數時候，我會把這個工作寫成一份通用 Playbook，並搭配 Workflow 來進行檢查。此外，Ansible 的 ping 是一個 Ansible 模組，而不是單純的 Linux 工具 ping。 具體的 ping Playbook 寫法如下： cat pingall.yml --- - hosts: \"{{ variable_host | default('all') }}\" tasks: - name: Test connectivity ping: register: result - name: Print result debug: msg: \"{{ result }}\" ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:9","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 10: 關閉 gather_facts 以加速執行速度 因為 Ansible 是 agentless，執行時預設會先去收集 host 上的環境資訊（例如 IP、hostname、OS 版本等）。然而，當管理的機器過多時，會發現收集這些資訊的時間過長。這時可以選擇將 gather_facts 設置為 false，以節省收集資訊的時間。 --- - hosts: all gather_facts: false tasks: - name: ... ... ... ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:10","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 11: 設定 fact_cache 以使用快取的環境變數 假設你真的需要用到 gather_facts 收集的環境資訊，但又不想在短時間內多次等待收集資訊的時間，可以在 ansible.cfg 中使用 fact_caching 來作為快取。這樣可以在一定時間內重用已收集的資訊，從而提高執行效率。 cat /etc/ansible/ansible.cfg [defaults] ... # 除了支援JSON file 以外，還另外支援 redis、memcached，在管大量機器的時候才需要搭配這方面的方案 fact_caching = jsonfile fact_caching_connection = /tmp/facts # hardtimeout fact_caching_timeout = 600 ... ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:11","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 12: 增加 ssh 參數以提升連線效率 這部分偏向於 SSH 的傳輸調教，主要是 ControlPersist 和 Pipelining 這兩個選項。 ControlPersist 可以讓 SSH 建立的連線一直保持著連線，建議開啟以減少重複連線的時間。 而 Pipelining 則可以減少 Ansible 控制節點到主機之間的連線數量，也有助於提升執行效率。 cat /etc/ansible/ansible.cfg [ssh_connection] ... ssh_args = -o ControlMaster=auto -o ControlPersist=300s control_path = %(directory)s/%%h-%%r pipelining = True ... ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:12","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 13: 收集 tasks 的處理時間 如果每次執行時都不知道哪個 task 跑得最久或卡在哪裡，可以使用 Ansible 插件 profile_tasks 來統計各個 task 的處理時間。這樣可以精確了解每個 task 的耗時，尤其是 Gathering Facts 所消耗的時間。 /etc/ansible/ansible.cfg [defaults] ... callback_whitelist = profile_tasks ... ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:13","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 14: 盡可能提供完整的 Inventory 資訊 盡可能在 Inventory 中提供明確的資訊，而不採用隱晦的資訊，尤其是 ansible_host。這樣可以確保每個人看到這份 Inventory 時的理解是一致的。 # 不建議 db1 # 建議 db1 ansible_host=10.1.2.75 ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:14","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"Suggestion 15: 對敏感工作禁用 Log 若不希望在log中留下任何敏感性資料，可以在該 Task 多加一個 no_log: True 來避免記錄敏感資訊。 - name: Secret Task shell: /usr/bin/gg --value={{ secret_value }} no_log: True ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:1:15","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["ansible"],"content":"References Ansible tips and tricks Ansible tips and tricks - Sample directory layout ","date":"2024-07-31","objectID":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/:2:0","tags":["automation","ansible","iac"],"title":"提升你的 Ansible 技能的幾個建議","uri":"/2024/07/20240731-suggestions_to_enhance_your_ansible_skills/"},{"categories":["vscode"],"content":"簡單紀錄一下我在VS Code裡面裝了哪些插件 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:0:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"Cloud維運 Ansible Terraform Dev Containers Kubernetes Remote - SSH - 可使用VS Code遠端連線開發 DotENV - .env syntax highlighting ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:1:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"文字編輯相關 YAML - YAML 檔的 syntax highlight Code Spell Checker - 檢測拼字錯誤 Even Better TOML - TOML 檔的 syntax highlight indent-rainbow - 縮排美化 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:2:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"Golang Go ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:3:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"Python Python Python Debugger Pylance - 微軟的Python Language Server Flake8 - Python Linter，符合PEP 8規範 Black Formatter - Python Formatter，符合PEP 8規範 isort - import排序，符合PEP 8規範 autoDocstring - Python Docstring Generator - 自動生產docstring，符合PEP 257規範 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:4:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"git相關 Git History - 可視化的git log GitLens — Git supercharged - 強大的git extension in VS Code Git Graph - 方便查看git分支圖形 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:5:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"Hugo工作流程(Markdown編輯) Hugo Language and Syntax Support Hugo Shortcode Syntax Highlighting Hugo Snippets Markdown All in One Markdown Preview Mermaid Support Marp for VS Code - 做 Marp Markdown 簡報的套件 Mermaid Markdown Syntax Highlighting Path Intellisense - 選擇圖檔路徑時節省時間 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:6:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"佈景主題 Chinese (Traditional) Language Pack for Visual Studio Code One Dark Pro - VS Code主題 Material Icon Theme - VS Code icon主題 ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:7:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["vscode"],"content":"settings.json設定 { \"workbench.iconTheme\": \"material-icon-theme\", \"workbench.colorTheme\": \"One Dark Pro Darker\", \"[python]\": { \"editor.defaultFormatter\": \"ms-python.black-formatter\", \"editor.codeActionsOnSave\": { \"source.organizeImports\": \"explicit\" } }, \"flake8.args\": [ \"--max-line-length=100\", \"--ignore=E131,E302\" ], \"black-formatter.args\": [ \"--line-length=100\", \"--skip-string-normalization\" ], \"isort.args\": [ \"--src=${workspaceFolder}\", \"--line-length=100\" ], \"isort.check\": true, \"autoDocstring.docstringFormat\": \"google-notypes\", \"git.ignoreRebaseWarning\": true, \"files.eol\": \"\\n\" } ","date":"2024-03-21","objectID":"/2024/03/20240321-vscode-plugins/:8:0","tags":["vscode"],"title":"我在VS Code裡面用了哪些插件","uri":"/2024/03/20240321-vscode-plugins/"},{"categories":["container"],"content":"寫在前面 ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:1:0","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"為什麼要這麼做？ 實際上我們並不需要也不需要直接編輯容器中的檔案。Docker 容器是不可修改的工作單元，用於運行單一、特定的進程。鏡像應該在沒有任何影響的情況下能夠被建立和運行。 只是在開發期間，對 Docker 容器中的文件進行編輯可能才有些用處，這讓我們在不需要重新建立鏡像的狀態下驗證是否達到了預期的效果，可以達到節省時間、提高開發效率的目的，但是在完成驗證後，應該刪除增加到鏡像中的多於內容，使驗證後的結果永久化到鏡像中。 另外需要提醒的一點是，當我們在一個運行著的容器中編輯一個文件後需要確保所依賴的這個文件的process收到了文件編輯的通知並進行了設定更新，如果沒有類似的通知機制，需要手動重啟這些process使修改能生效。 下面假設你所使用的容器中沒有 vi 等文字編輯工具，我們以 openjdk:23 作為示範： docker run -it openjdk:23 bash root@d0fb3a0b527c:/# vi demo.java bash: vi: command not found root@d0fb3a0b527c:/# ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:1:1","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"以下介紹五種常用方法 ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:0","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法1：使用掛載 準備Dockerfile： FROM openjdk:23 WORKDIR \"/app\" 編譯鏡像： docker build -t sample . 最後，運行標記為掛載的容器： docker run --rm -it --name=sample_demo -v $PWD/app-vol:/app sample bash 如果本機 $PWD/app-vol 目錄不存在，會自動建立。此後在 $PWD/app-vol 下的檔案操作會對應在容器的 /app 目錄下。 ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:1","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法2：安裝編輯器 準備Dockerfile： FROM openjdk:23 WORKDIR \"/app\" 編譯鏡像： docker build -t sample . 啟動容器並進行vim編輯器安裝： docker run --rm -it --name=sample_demo sample bash root@4b72fbabb0af:/app# apt-get update root@4b72fbabb0af:/app# apt-get -y install vim 如果需要重複使用，更好的做法是寫在 Dockerfile 中： FROM openjdk:23 RUN [\"apt-get\", \"update\"] RUN [\"apt-get\", \"-y\", \"install\", \"vim\"] WORKDIR \"/app\" ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:2","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法3：將文件複製到正在運行的容器中 docker cp demo.java sample_demo:/app 另一個類似的方法只要 docker exec 和 cat 結合使用，下面的指令同樣把 demo.java 檔案複製到正在運作的容器中： docker exec -i sample_demo sh -c 'cat \u003e /app/demo.java' \u003c demo.java ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:3","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法4：使用Linux工具 雖然容器中通常沒有安裝編輯工具，但是其他Linux工具，如：sed、awk、echo、cat、cut等還是有的，可以派上用場。例如sed和awk可以編輯文件的適當位置，還可以將echo , cat, cut 聯合起來並藉助強大的指令流和編輯文件。如前文所示，這些工具可以與docker exec 命令結合使用，從而發揮更強大的威力。 ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:4","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["container"],"content":"方法5：使用遠端vim（或其他編輯器） 這種方法只是為了開拓思路，並不會在實際中使用，因為並不安全。 準備Dockerfile： FROM openjdk:23 RUN [\"apt-get\", \"update\"] RUN [\"apt-get\", \"install\", \"-y\", \"openssh-server\"] RUN mkdir /var/run/sshd RUN echo 'root:password' | chpasswd RUN sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config RUN [\"/etc/init.d/ssh\", \"start\"] EXPOSE 22 WORKDIR \"/app\" CMD [\"/usr/sbin/sshd\", \"-D\"] 因為我們要藉助 scp 來遠端進行檔案編輯，所以需要安裝 openssh-server 並開放其連接埠。 編譯並運行： docker build -t sample . docker run --rm -p 2222:22 -d --name=sample_demo sample 現在我們可以使用以下指令來編輯demo.java檔了： vim scp://root@localhost:2222//app/demo.java 註：在 vi 需要先執行 :set bt=acwrite 指令再去編輯文件，相關討論請見：https://github.com/vim/vim/issues/2329 編輯完成儲存並退出後，可以使用下面的命令來驗證檔案確實被建立和儲存了： docker exec -it sample_demo cat /app/demo.java ","date":"2024-03-13","objectID":"/2024/03/20240313-edit-docker-container-file/:2:5","tags":["container"],"title":"編輯docker容器中的文件","uri":"/2024/03/20240313-edit-docker-container-file/"},{"categories":["linux"],"content":"我們在登入伺服器，執行一個較耗時的程式時，通常我們會使用 nohup command \u0026 的方式執行，如果我們在啟動時，忘記加上這 nohup 能否成功呢？ 首先使用 control + z 讓目前process暫停（Suspend）。 然後我們使用 jobs 來查看它的jobspec。 再用 bg %jobspec 來放入背景並繼續執行。 最後使用 disown -h %jobspec 來使該作業忽略 HUP 訊號。 這個方法可以用在 scp 的指令中，在沒有設定 ssh 無密碼登入的情況下，我們無法使用 nohup 來執行 scp 指令，所以只能在開始大檔案copy後，透過上述方法讓這個程式被放置在背景執行。 ","date":"2024-03-11","objectID":"/2024/03/20240311-run-in-background/:0:0","tags":["linux","nohup"],"title":"把程式移動至背景執行的方式","uri":"/2024/03/20240311-run-in-background/"},{"categories":["linux"],"content":"References Shell Scripting – JOB SPEC \u0026 Command ","date":"2024-03-11","objectID":"/2024/03/20240311-run-in-background/:1:0","tags":["linux","nohup"],"title":"把程式移動至背景執行的方式","uri":"/2024/03/20240311-run-in-background/"},{"categories":["java"],"content":"方法有這三種 使用hibernate.cfg.xml文件建立Hibernate SessionFactory 使用Java HashMap和ServiceRegistry class在Hibernate中建立SessionFactory 從JPA的EntityManager中獲得Hibernate SessionFactory ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:0:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["java"],"content":"1. 使用hibernate.cfg.xml文件建立Hibernate SessionFactory 這是官方建議的方法，hibernate.cfg.xml內容如下: \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e \u003c!DOCTYPE hibernate-configuration PUBLIC \"-//Hibernate/Hibernate Configuration DTD 3.0//EN\" \"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd\"\u003e \u003chibernate-configuration\u003e \u003csession-factory\u003e \u003cproperty name=\"connection.driver_class\"\u003ecom.mysql.cj.jdbc.Driver\u003c/property\u003e \u003c!-- property name=\"connection.driver_class\"\u003ecom.mysql.jdbc.Driver\u003c/property --\u003e \u003cproperty name=\"connection.url\"\u003ejdbc:mysql://localhost/hibernate_examples\u003c/property\u003e \u003cproperty name=\"connection.username\"\u003eroot\u003c/property\u003e \u003cproperty name=\"connection.password\"\u003epassword\u003c/property\u003e \u003cproperty name=\"connection.pool_size\"\u003e3\u003c/property\u003e \u003cproperty name=\"dialect\"\u003eorg.hibernate.dialect.MySQL8Dialect\u003c/property\u003e \u003cproperty name=\"current_session_context_class\"\u003ethread\u003c/property\u003e \u003cproperty name=\"show_sql\"\u003etrue\u003c/property\u003e \u003cproperty name=\"format_sql\"\u003etrue\u003c/property\u003e \u003cproperty name=\"hbm2ddl.auto\"\u003eupdate\u003c/property\u003e \u003c!-- mapping class=\"com.mcnz.jpa.examples.Player\" / --\u003e \u003c/session-factory\u003e \u003c/hibernate-configuration\u003e 接著在就可以在Java內去建立Hibernate SessionFactory: public static Session getCurrentSessionFromConfig() { // SessionFactory in Hibernate 5 example Configuration config = new Configuration(); config.configure(); // local SessionFactory bean created SessionFactory sessionFactory = config.buildSessionFactory(); Session session = sessionFactory.getCurrentSession(); return session; } ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:1:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["java"],"content":"2. 使用Java HashMap和ServiceRegistry class在Hibernate中建立SessionFactory 個人覺得用xml檔來儲存像是資料庫位址與帳密實在是太危險，好在能夠使用一個HashMap來把資料儲存起來傳送給ServiceRegistry，這樣就不需要去建立hibernate.cfg.xml了 更正:將資料庫與帳密等變數資訊加密後放置在主機的環境變數會是較好的做法 public static Session getCurrentSession() { // Hibernate 5.4 SessionFactory example without XML Map\u003cString, String\u003e settings = new HashMap\u003c\u003e(); settings.put(\"connection.driver_class\", \"com.mysql.jdbc.Driver\"); settings.put(\"dialect\", \"org.hibernate.dialect.MySQL8Dialect\"); settings.put(\"hibernate.connection.url\", \"jdbc:mysql://localhost/hibernate_examples\"); settings.put(\"hibernate.connection.username\", \"root\"); settings.put(\"hibernate.connection.password\", \"password\"); settings.put(\"hibernate.current_session_context_class\", \"thread\"); settings.put(\"hibernate.show_sql\", \"true\"); settings.put(\"hibernate.format_sql\", \"true\"); ServiceRegistry serviceRegistry = new StandardServiceRegistryBuilder() .applySettings(settings).build(); MetadataSources metadataSources = new MetadataSources(serviceRegistry); // metadataSources.addAnnotatedClass(Player.class); Metadata metadata = metadataSources.buildMetadata(); // here we build the SessionFactory (Hibernate 5.4) SessionFactory sessionFactory = metadata.getSessionFactoryBuilder().build(); Session session = sessionFactory.getCurrentSession(); return session; } ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:2:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["java"],"content":"3. 從JPA的EntityManager中獲得Hibernate SessionFactory 直接使用JPA去取得 hibernate session內的資料 public static SessionFactory getCurrentSessionFromJPA() { // JPA and Hibernate SessionFactory example EntityManagerFactory emf = Persistence.createEntityManagerFactory(\"jpa-tutorial\"); EntityManager entityManager = emf.createEntityManager(); // Get the Hibernate Session from the EntityManager in JPA Session session = entityManager.unwrap(org.hibernate.Session.class); SessionFactory factory = session.getSessionFactory(); return factory; } ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:3:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["java"],"content":"References Build a Hibernate SessionFactory by example ","date":"2023-05-08","objectID":"/2023/05/20230119-hibernate-sessionfactory/:4:0","tags":["hibernate","java"],"title":"在Java中建立Hibernate SessionFactory的三種方法","uri":"/2023/05/20230119-hibernate-sessionfactory/"},{"categories":["aws"],"content":"在使用AWS Lambda的時候，發現它裡面的時區並不會使用使用者帳號所設定的時區，都是使用UTC時區。 如果要改變AWS Lambda所使用的時區的話，只要去各Lambda function的Environment variables裡面設定就可以了 ","date":"2023-05-08","objectID":"/2023/05/20230508-aws-timezone/:0:0","tags":["aws"],"title":"AWS Lambda 時區變更","uri":"/2023/05/20230508-aws-timezone/"},{"categories":["aws"],"content":"Environment variables Key Value Tz Asia/Taipei ","date":"2023-05-08","objectID":"/2023/05/20230508-aws-timezone/:1:0","tags":["aws"],"title":"AWS Lambda 時區變更","uri":"/2023/05/20230508-aws-timezone/"},{"categories":["java"],"content":"1. HQL（Hibernate Query Language） @Override public SysUser findUserByLoginName(String pLoginName) { String hql = \"from SysUser as u where u.loginName = ?\"; List\u003cSysUser\u003e users = getHibernateTemplate().find(hql, pLoginName); return users.isEmpty() ? null : users.get(0); } ","date":"2023-05-08","objectID":"/2023/05/20230508-hibernate-query/:1:0","tags":["hibernate","java"],"title":"Hibernate三種查詢資料的方式","uri":"/2023/05/20230508-hibernate-query/"},{"categories":["java"],"content":"2. SQL（Structured Query Language） static List sql() { Session s = HibernateUtil.getSession(); Query q = s.createSQLQuery(\"select * from user\").addEntity(User.class); List\u003cUser\u003e rs = q.list(); s.close(); return rs; } ","date":"2023-05-08","objectID":"/2023/05/20230508-hibernate-query/:2:0","tags":["hibernate","java"],"title":"Hibernate三種查詢資料的方式","uri":"/2023/05/20230508-hibernate-query/"},{"categories":["java"],"content":"3. QBC（Query By Criteria） //查詢符合條件的帳號 Criteria c=s.createCriteria(Admin.class); c.add(Restrictions.eq(\"aname\",name)); c.add(Restrictions.eq(\"apassword\", password)); List\u003cAdmin\u003e list=c.list(); //列出分頁前10項 Criteria criteria = session.createCriteria(Customer.class); criteria.addOrder( Order.asc(\"name\") ); //排序方式 criteria.setFirstResult(0); criteria.setMaxResults(10); List result = criteria.list（） ","date":"2023-05-08","objectID":"/2023/05/20230508-hibernate-query/:3:0","tags":["hibernate","java"],"title":"Hibernate三種查詢資料的方式","uri":"/2023/05/20230508-hibernate-query/"},{"categories":["misc"],"content":"總之是個值得紀念的第一個文章 ","date":"2023-01-19","objectID":"/2023/01/first-post/:0:0","tags":["misc"],"title":"First Post","uri":"/2023/01/first-post/"},{"categories":null,"content":"贊助 Donate","date":"2023-01-19","objectID":"/donate/","tags":null,"title":"贊助 Donate","uri":"/donate/"},{"categories":null,"content":"如果你覺得我的文章很棒，可以贊助我一杯咖啡 點我連結 ","date":"2023-01-19","objectID":"/donate/:0:0","tags":null,"title":"贊助 Donate","uri":"/donate/"},{"categories":null,"content":"About Divazone King","date":"2022-07-09","objectID":"/about/","tags":null,"title":"About Divazone King","uri":"/about/"},{"categories":null,"content":"Just a software engineer ","date":"2022-07-09","objectID":"/about/:0:0","tags":null,"title":"About Divazone King","uri":"/about/"}]